#!KAMAILIO
#
# Kamailio SIP Router Configuration
# Multi-PBX routing with load balancing and failover
#

####### Global Parameters #########

debug=2
log_stderror=no
memdbg=5
memlog=5
log_facility=LOG_LOCAL0
fork=yes
children=4

/* Listen interfaces */
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5061
# listen=tls:0.0.0.0:5063  # Enable for TLS

/* Aliases */
alias="sip.company.local"

####### Modules Section ########

loadmodule "tm.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "dispatcher.so"  # Load balancing
loadmodule "db_mysql.so"
loadmodule "rtpengine.so"   # Media proxy (optional)

/* Module Parameters */

# MySQL connection
modparam("dispatcher", "db_url", "mysql://kamailio:kamailio_pwd@mysql/kamailio")
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dst_avp", "$avp(dsdst)")
modparam("dispatcher", "grp_avp", "$avp(dsgrp)")
modparam("dispatcher", "cnt_avp", "$avp(dscnt)")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_ping_from", "sip:ping@kamailio")
modparam("dispatcher", "ds_probing_mode", 1)

# RTPEngine
modparam("rtpengine", "rtpengine_sock", "udp:rtpengine:22222")

# Record routing
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

####### Routing Logic ########

request_route {
    # Per request initial checks
    route(REQINIT);

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    # Handle registrations
    route(REGISTRAR);

    # Route to backend PBX via dispatcher
    route(DISPATCH);
}

# Request initial checks
route[REQINIT] {
    # Flood detection
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    # Sanity checks
    if (!sanity_check()) {
        xlog("Malformed SIP message\n");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (has_totag()) {
        if (loose_route()) {
            route(RELAY);
        } else {
            if (is_method("ACK")) {
                if (t_check_trans()) {
                    route(RELAY);
                    exit;
                }
            }
            sl_send_reply("404", "Not here");
        }
        exit;
    }
}

# REGISTRAR - handle phone registrations
route[REGISTRAR] {
    if (is_method("REGISTER")) {
        # Forward REGISTER to appropriate backend PBX
        # Based on extension range or domain

        # Extension range routing
        $var(extension) = $au;  # Get username from auth

        # Route by extension range
        if ($var(extension) =~ "^1[0-9]{3}$") {
            # 1000-1999 → Backend Set 1
            $avp(dsgrp) = "1";
        } else if ($var(extension) =~ "^2[0-9]{3}$") {
            # 2000-2999 → Backend Set 2
            $avp(dsgrp) = "2";
        } else {
            # Default → Backend Set 1
            $avp(dsgrp) = "1";
        }

        if (!ds_select_dst("$avp(dsgrp)", "4")) {
            send_reply("404", "No backend available");
            exit;
        }

        route(RELAY);
        exit;
    }
}

# DISPATCH - route calls to backend PBXes
route[DISPATCH] {
    # Route based on extension, domain, or load balance

    # Extension-based routing
    $var(called) = $rU;  # Called number

    if ($var(called) =~ "^1[0-9]{3}$") {
        # Extensions 1000-1999 → Set 1
        if (!ds_select_dst("1", "4")) {
            send_reply("404", "No backend");
            exit;
        }
    } else if ($var(called) =~ "^2[0-9]{3}$") {
        # Extensions 2000-2999 → Set 2
        if (!ds_select_dst("2", "4")) {
            send_reply("404", "No backend");
            exit;
        }
    } else {
        # Default: Load balance across all (Set 1)
        if (!ds_select_dst("1", "4")) {
            send_reply("404", "No backend");
            exit;
        }
    }

    # Enable RTPEngine for media proxying
    rtpengine_manage();

    route(RELAY);
}

# RELAY - forward request to backend
route[RELAY] {
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Reply route - handle responses
onreply_route {
    # RTPEngine for responses
    rtpengine_manage();
}

# Failure route - handle backend failures
failure_route[RTF_DISPATCH] {
    if (t_check_status("408|503")) {
        # Backend timeout or unavailable
        # Try next backend in set
        if (ds_next_dst()) {
            route(RELAY);
            exit;
        }
    }
}
